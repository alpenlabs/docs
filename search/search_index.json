{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Strata","text":"<p>Note</p> <p>Strata Devnet is live! To build on the devnet, please apply using the devnet form on our website.</p> <p>Strata gives developers the freedom to program nearly any locking conditions for BTC imaginable, limited only by the Strata block size and gas limits. This enables developers to create new kinds of applications for BTC with features such as:</p> <ul> <li> <p>New signature types, \"provide a valid <code>P-256</code> signature to authorize a transfer\"</p> </li> <li> <p>Vaults, \"transfers must wait <code>N</code> days after being initiated to be effectuated,   and can be cancelled in the mean time\"</p> </li> <li> <p>Subscriptions, \"address <code>0x123...9a</code> can withdraw up to <code>v</code> BTC   per month from this account\"</p> </li> <li> <p>Strong privacy, \"transaction details are end-to-end encrypted   and verified using a zero-knowledge proof\"</p> </li> <li> <p>Economically secured zero-confirmation payments,   \"if a double-spend from this sender is reported,   the reporter gets to claim the sender's full wallet balance\"</p> </li> <li> <p>Financial transactions,   \"if enough BTC is locked as collateral to maintain up   to <code>X%</code> loan-to-value ratio,   then up to N of this other asset can be borrowed\"</p> </li> </ul> <p>... and many more possibilities.</p> <p>Technically speaking, Strata is a work-in-progress EVM-compatible validity rollup on bitcoin. Let's break down what this means:</p> <ul> <li> <p>EVM-compatible: The Strata block producer runs a client that is based on   Reth,   an Ethereum execution client.   So far, no changes have been made that affect compatibility with the EVM spec.   If you can deploy a smart contract to Ethereum,   you can deploy it to Strata with no changes.</p> </li> <li> <p>Validity rollup: Every Strata state transition is proven to   be valid using cryptographic validity proofs,   which clients can use for fast, low-cost verification.</p> </li> <li> <p>On bitcoin: Strata uses bitcoin for consensus and data availability.   When a Strata block gets confirmed on bitcoin,   the only way to reorganize this block is to reorganize   the bitcoin block that the Strata block was confirmed in.</p> </li> </ul> <p>You can find detailed technical information in the \"How Strata works\" section of this documentation.</p> <p>Note</p> <p>During the devnet phase, Strata will be running on a private bitcoin signet, and will use signet blocks to store state commitments rather than the complete Strata state data, making Strata function more like a commit chain than a rollup. Support for full onchain data availability and for running Strata on bitcoin mainnet are planned for future releases.</p>"},{"location":"technical/architecture/","title":"System architecture","text":"<p>Note</p> <p>Although Strata is designed to run on bitcoin mainnet, currently Strata is only running on a bitcoin signet. Any references to bitcoin or BTC in this documentation should be read as \"bitcoin signet\" or \"signet BTC\" when describing the current system.</p> <p>Strata is an EVM blockchain that uses bitcoin as a source of truth for state commitments and proof of valid state transitions. The user's application layer interacts with Strata in three ways:</p> <ol> <li>Through the full node,    which provides both Ethereum-compatible RPCs and additional Strata RPCs,    enabling users to send EVM transactions to Strata.</li> <li>Through the bundler,    which handles the bundling of account abstraction (ERC-4337) transactions,    also known as UserOperations.</li> <li>Through bitcoin,    which allows users to deposit BTC into the Strata system.</li> </ol>      Architecture diagram.    <p>The diagram above illustrates the overall system architecture and the data flow between different components of Strata and the entities interacting with the system. There are three layers: bitcoin layer at the base, Strata layer above it, and the user application layer that sits on top of the Strata layer. The direction of arrows indicate the direction of data flow between the components, and the text in the arrows indicate the data. The centralized services are the services that are run by Alpen Labs. Other components within Strata layer (the bundler and the full node) can be run by anyone in our devnet community.</p>"},{"location":"technical/architecture/#user-application-layer","title":"User application layer","text":"<p>The user application layer is not part of Strata but includes any interface or application that acts as a gateway for users to interact with Strata. These applications include wallets (e.g. EOA wallets, account abstraction wallets, bitcoin wallets), decentralized applications (e.g. Uniswap), smart contract deployment tools (e.g. Foundry), and command-line interface tools (e.g. Cast). They interact programmatically with a Strata full node, bundler, and bitcoin through an RPC interface provided by each service, and the RPC interfaces enable applications to interact with Strata, including deploying smart contracts, sending EOA or account-abstraction transactions, and initiating deposits into Strata.</p>"},{"location":"technical/architecture/#bundler","title":"Bundler","text":"<p>The bundler supports account abstraction by accepting <code>UserOperation</code> transactions as defined by ERC-4337. It bundles these transactions and relays them to the full node.</p> <p>We have deployed a bundler for devnet that developers can use as an endpoint to send UserOperations. Anyone else can also run their own bundler to connect with the full node network independently.</p>"},{"location":"technical/architecture/#full-node","title":"Full node","text":"<p>A full node is a software client that runs Strata\u2019s core logic and provides an RPC interface for programs to interact with Strata. It receives transactions from the user application layer or bundler and relays them to the sequencer. Periodically, the full node polls the sequencer for new blocks. If new blocks are available, they are then downloaded and executed against the full node's current state, advancing the state. This new state remains unconfirmed until the full node sees that the relevant batch checkpoint posted on bitcoin by the sequencer has been confirmed.</p> <p>Internally, a full node is constructed similarly to a post-merge Ethereum full node, keeping modularity in mind, separating the node into an execution layer and an orchestration layer. They interact with each other through a slightly modified Engine API, which we extended to handle bridge transfers in/out of execution layer.</p> <p>For devnet, Alpen is running a full node that developers can connect to via RPC to interact with Strata. Additionally, anyone in the devnet community can run their own full node by building the full node source code.</p>"},{"location":"technical/architecture/#sequencer","title":"Sequencer","text":"<p>The sequencer is currently a centralized component that performs the functions of sequencing transactions in its mempool, validating the transactions, bundling the valid transactions into blocks, creating and signing a new block of transactions approximately every 5 seconds, and sharing blocks with full nodes upon request. The sequencer also decides the range of blocks (aka a batch) to be proven, relays that information to the prover, and posts the batch checkpoint to bitcoin. A batch checkpoint includes the batch metadata and the proof generated by the prover.</p> <p>The sequencer is therefore the primary component in the Strata system performing the necessary actions that enable full nodes to advance the chain to the next state.</p> <p>For devnet, Alpen runs the sequencer, and full nodes only accept checkpoints signed by the sequencer.</p>"},{"location":"technical/architecture/#prover","title":"Prover","text":"<p>The prover gets information from the sequencer about the next batch the prover is generating a proof for. The prover then produces a recursive validity proof that proves the validity of the current batch, as well as all batches before it, according to the Strata consensus rules. At a high level, the proof ensures that:</p> <ol> <li>All bitcoin blocks in the batch have been thoroughly scanned    for user deposit transactions, previous proofs, and checkpoints.</li> <li>The state transition resulting from executing    the current batch and deposit transactions is valid.</li> <li>The previous batch proof on bitcoin is valid.</li> </ol> <p>This recursive proof enables a verifier to validate the Strata chain's entire history, from genesis to the latest state. The proof is passed to the sequencer, who then posts it to the bitcoin network along with the batch metadata (state commitments).</p> <p>Info</p> <p>For devnet, even though Strata produces recursive proofs and posts them to our private signet network, we use devnet as a testing and experimentation ground for proofs, starting and stopping proof generation at unpredictable times. Therefore, external systems should not assume that each proof proves state transition from genesis. Rather, each proof accompanies public inputs that mention the range of batches it proves recursively. Full nodes in the Strata devnet network do not depend on proofs but can re-execute blocks to transition states. The next Strata milestone will support nodes that fully depend on proofs posted on the bitcoin layer for their state.</p>"},{"location":"technical/architecture/#bridge-operator","title":"Bridge operator","text":"<p>A bridge operator is one of \\(N\\) nodes collectively performing the functions of processing user deposit and withdrawal requests by locking the user's BTC in the \\(N\\)-of-\\(N\\) multisig on bitcoin and by releasing the appropriate amount of BTC back to the user's bitcoin address, respectively. Each bridge operator monitors bitcoin for a special deposit request transaction, in which the user allows the bridge operators to transfer the user's BTC to an \\(N\\)-of-\\(N\\) multisig address within a specified amount of time. The bridge operators then cooperate and sign a deposit transaction that transfers the user's funds to the \\(N\\)-of-\\(N\\) multisig address within the alloted time. When this transaction is confirmed on bitcoin, an equivalent amount of BTC is minted to the user's designated Strata account. Similarly, for each confirmed withdrawal request on Strata, the bridge operators cooperate to sign and broadcast a withdrawal transaction to bitcoin that transfers the appropriate BTC amount to the user's designated bitcoin address. Detailed descriptions of the deposit and withdrawal mechanisms can be found in the bitcoin bridge documentation. Currently, the bridge is an \\(N\\)-of-\\(N\\) multisig, with all bridge operators run by Alpen. A more secure bridge that provides a single-functional-user trust assumption is targeted for the next major Strata release.</p>"},{"location":"technical/bitcoin-bridge/","title":"Bitcoin bridge","text":"<p>Note</p> <p>Although Strata is designed to run on bitcoin mainnet, currently Strata is only running on a bitcoin signet. Any references to bitcoin or BTC in this documentation should be read as \"bitcoin signet\" or \"signet BTC\" when describing the current system.</p> <p>The Strata bitcoin bridge enables the transfer of BTC between the bitcoin and Strata blockchains. The bridge is run by a federation of operators who co-sign transactions to move BTC into and out of the Strata bridge address.</p> <p>Info</p> <p>The current bridge design assumes an N-of-N cooperation amongst the bridge operators. Future designs will improve the liveness and safety guarantees of the bridge.</p> <p>The deposit flow is composed of a Deposit Request Transaction (DRT) which is fulfilled by the bridge federation with a Deposit Transaction (DT). The user must provide an Execution Layer (EL) address to receive BTC on Strata.</p> <p>The withdrawal request is assigned to an operator who fulfills the request by creating a transaction spending BTC from the bridge address to the user's specified withdrawal address. Once the other <code>N-1</code> operators co-sign this transaction it is broadcast to bitcoin for confirmation.</p> <p>Note</p> <p>Deposits and withdrawals are allowed in a denomination of \\(D\\) BTC where \\(D = 10 \\ \\text{BTC}\\) is a value predefined by the bridge federation.</p> <p>The operator fee is set at 5% of the bridge denomination. The minimum relay fee for transactions is 10 satoshis per vByte.</p> <p>Info</p> <p>All the multisigs in the deposit and withdrawal flows follow the MuSig2 protocol, where signatures are aggregated into a single signature that validates all \\(N\\) participants' partial signatures.</p>"},{"location":"technical/bitcoin-bridge/#deposit","title":"Deposit","text":"<p>The deposit process is initiated by the user, who sends 10<sup>1</sup> BTC to a P2TR address, where:</p> <ol> <li>The key path spend is unspendable, following    BIP 341    with a \"NUMS\"<sup>2</sup> point added to the random scalar    \\(r = \\text{0x82758434e13488368e0781c4a94019d3d6722f854d26c15d2d157acd1f464723}\\).</li> </ol> <ol> <li> <p>The script path spend has two paths:</p> <ol> <li> <p>\"Deposit path\", an \\(N\\)-of-\\(N\\) multisig path,    where \\(N\\) is the number of operators in the bridge.    Note that this uses Schnorr key aggregation,    hence the signature is aggregated into a single signature that    validates all \\(N\\) operators' signatures.</p> </li> <li> <p>\"Take back\" path,    which allows the user to take back their funds if the bridge fails to    move funds from the Deposit Request Transaction (DRT)    into the bridge address within approximately 8.5 hours,    i.e. it is time-locked and the user can spend it by providing a signature.</p> </li> </ol> </li> </ol> <p>This transaction has some metadata attached to it, in the form of an <code>OP_RETURN</code> output, that must be the second output of the transaction in order for the sequencer to be able to detect the transaction. The <code>OP_RETURN</code> output can be up to 80 bytes long (according to bitcoin standardness policy), and is composed of the following data:</p> <ol> <li>Magic bytes.    These take \\(11\\) bytes and are used to identify the bridge.</li> <li>\"Take back\" TapLeaf hash.    These take \\(32\\) bytes and are used to validate the    Deposit Request Transaction (DRT),    while also necessary for the control block required    to spend the P2TR output via the \\(N\\)-of-\\(N\\) Tapscript.</li> <li>Execution Layer (EL) address.    The Execution Layer (EL) address is the Strata address where    the user wants to receive the BTC in Strata.    It is a 20-byte Ethereum Virtual Machine (EVM) address.    This is \\(20\\) bytes long.</li> </ol> <p>The bridge monitors the blockchain for incoming transactions, which can be detected by the <code>OP_RETURN</code> output. Once the bridge detects the Deposit Request Transaction (DRT), it verifies the \"take back\" TapLeaf hash, the multisig pubkey path, and the full Taproot commitment.</p> <p>If the Deposit Request Transaction (DRT) is valid, the bridge operators fulfill the deposit with a Deposit Transaction (DT) that transfers the BTC to the bridge address's UTXO set and also mints the same amount of BTC to the Execution Layer (EL) address provided by the user.</p> <p>Below in the figure is the deposit flow:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Bitcoin\n    participant Bridge\n\n    User-&gt;&gt;Bitcoin: DRT\n    Bitcoin-&gt;&gt;Bitcoin: DRT\n    Bitcoin-&gt;&gt;Bridge: DRT\n    Bridge-&gt;&gt;Bridge: DRT\n    Bridge-&gt;&gt;Bitcoin: DRT-DT\n    Bitcoin-&gt;&gt;Bitcoin: DT\n    Bridge-&gt;&gt;Bridge: Mint</code></pre>"},{"location":"technical/bitcoin-bridge/#withdrawal","title":"Withdrawal","text":"<p>The user requests a withdrawal on Strata and an operator is assigned to fulfill the request on bitcoin:</p> <ol> <li>The user initiates a withdrawal request, in response to which    the corresponding amount of BTC is burned on Strata.</li> <li>After the burn is confirmed, the assigned operator creates    and signs a Withdrawal Transaction (WT) on the bitcoin blockchain    where they spend 10 BTC from the bridge address' UTXO set,    while subtracting the operator's fee (5% of the bridge denomination)    and the mining fee (minimum 10 satoshis per vByte),    and requests the other \\(N-1\\) operators to sign    the Withdrawal Transaction.</li> <li>Once all the signatures have been aggregated, the transaction is submitted to    bitcoin.</li> <li>Once the transaction is confirmed,    the withdrawal request is fulfilled.</li> </ol> <p>The withdrawal flow is shown below:</p> <pre><code>sequenceDiagram\n    participant User\n    participant Operator\n    participant Bridge\n    participant Bitcoin\n\n    User-&gt;&gt;User: Burn\n    User-&gt;&gt;Bridge: Withdrawal\n    Bridge-&gt;&gt;Operator: Duty\n    Operator-&gt;&gt;Bitcoin: WT\n    Operator-&gt;&gt;Operator: WT\n    Bitcoin-&gt;&gt;Bitcoin: WT</code></pre> <ol> <li> <p>The user must pay the bitcoin network fees for both the Deposit Request and Deposit Transactions.\u00a0\u21a9</p> </li> <li> <p>\"Nothing Up My Sleeve\" (NUMS) point, i.e., a point with unknown discrete logarithm, constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point \\(G\\) as \\(X\\) coordinate, as per BIP 341. An unspendable pubkey is a point on the curve whose discrete log is not known with respect to the generator point \\(G\\). This can be verified by revealing the random scalar \\(r\\) used to generate the pubkey by shifting the NUMS point.\u00a0\u21a9</p> </li> </ol>"},{"location":"technical/comparing-ethereum/","title":"Comparing Strata and Ethereum","text":""},{"location":"technical/comparing-ethereum/#evm-compatibility","title":"EVM compatibility","text":"<p>Strata is an EVM-compatible blockchain. The execution client used by the Strata block producer is based on Reth and is fully compatible with the EVM spec up to the Shanghai release. During the devnet phase, Strata can be considered a Type 1 zkEVM.</p> <p>Note</p> <p>In a future release, Strata developers plan to introduce changes that will result in a Type 2.5 zkEVM rating.</p>"},{"location":"technical/comparing-ethereum/#blockchain-functionality","title":"Blockchain functionality","text":"<p>Comparing differences in how Strata and Ethereum functionally operate:</p> Strata Devnet Ethereum Consensus: Proof of Authority Proof of Stake Gas asset: BTC ETH Block gas limit: 15,000,000 30,000,000 Block time: ~5s ~12s Finality: Probabilistic, blocks are confirmed in batches on a private bitcoin signet about once per hour ~15m"},{"location":"technical/design-rationale/","title":"Strata design rationale","text":"<p>In designing Strata, we adopted a structure inspired by Ethereum's post-merge (formerly \"2.0\") architecture, where each full node consists of two distinct components: an execution client and a consensus client. In Ethereum, the consensus client manages Proof of Stake (PoS) consensus, including proposer selection and block finalization, while the execution client is responsible for transaction execution using the EVM interpreter and processing user-facing application-level queries. These two clients communicate via the Engine API, which allows them to exchange necessary information, such as when the consensus client requests the execution client to process a block.</p> <p>Similarly, the Strata network is divided into two blockchains, with each full node able to run a client for each of the following layers:</p> <ol> <li>Execution layer: Handles transaction execution and chain state.</li> <li>Orchestration layer    (our version of Ethereum's consensus layer):    Coordinates various specialized tasks related to bitcoin interactions,    bridge operations, decentralized sequencing,    and other Strata-specific operations.</li> </ol> <p>In our architecture, the execution layer is an EVM environment implemented using a fork of Reth, while the orchestration layer is a new blockchain tailored to implement Strata's rollup design and support its consensus requirements. The two layers communicate via a slightly modified version of the Engine API, which we extended to handle specific features like bridge transfers in/out of the execution layer. This modification was necessary as Ethereum's Engine API doesn't natively support this functionality.</p>"},{"location":"technical/design-rationale/#advantages-of-separation","title":"Advantages of separation","text":"<p>By following Ethereum's well-thought-out approach to separating execution and orchestration, Strata gains important advantages:</p> <ul> <li> <p>Modularity and specialization:   The execution and orchestration layers have distinct, specialized functions.   This separation allows them to be developed, maintained,   and iterated upon independently.   For example, improvements to the orchestration layer's coordination logic   can be made without impacting the execution layer, and vice versa.</p> </li> <li> <p>Future support for multiple execution environments:   This separation allows us to support different execution environments in the future,   each conforming to our modified Engine API.   This means a future with different kinds of execution layers   (eg. WASM-based, privacy-focused, etc.), on top of the orchestration layer,   all having the ability to easily and trustlessly interoperate.</p> </li> </ul>"},{"location":"technical/design-rationale/#why-we-chose-a-custom-solution-over-existing-sdks","title":"Why we chose a custom solution over existing SDKs","text":"<p>We initially started development with an existing SDK but, after several months, chose to start over from scratch due to the challenges of relying on third-party tools. While SDKs like Sovereign SDK, Rollkit, and OP Stack could have sped up early development, we opted to build a custom orchestration layer for several key reasons:</p> <ul> <li>Complete control and flexibility:   Our main objective was to retain full control over the development of   our orchestration and consensus logic.   This allows us to introduce advanced features\u2014such as instant preconfirmations,   slashing for misbehavior, interoperability,   and volition-style hybrid DA\u2014on our own timeline,   without being restricted by external SDK limitations.   While pre-built SDKs provide basic functionalities,   extending beyond those often requires coordination with external teams,   which may create friction if the roadmaps are misaligned.   Building our own solution ensures we can evolve our architecture independently.</li> <li>Avoiding development bottlenecks:   During our initial development with a third-party SDK,   we encountered multiple limitations that slowed our progress.   In one instance, something as simple as retrieving   the status of an EVM transaction on the bitcoin chain required suboptimal workarounds   due to the difficulty in modifying the SDK's interface.   Although the SDK team eventually supported us   in making SDK changes or providing better solutions,   relying on external fixes introduced delays.   By building our orchestration layer from scratch,   we eliminate these bottlenecks,   enabling faster iterations and more efficient development.</li> <li>Limitations of current SDKs for our use case:   Most of the available third-party SDKs, mostly by design,   lack native support for rollups with bitcoin as the settlement layer.   OP Stack, for instance, is centered on optimistic rollups   and fault proofs on Ethereum. Sovereign SDK and Rollkit, while flexible,   are built around generic rollup use cases and typically integrate with EVM   or Cosmos-like ecosystems.   In contrast, Strata's architecture is specifically designed for a rollup   that settles to bitcoin and includes a validating bridge to and from bitcoin.   This requires unique design considerations,   such as accommodating bitcoin's UTXO transaction model,   limited scripting capabilities, and probabilistic settlement.   Our bitcoin-centric approach enabled us to easily incorporate a   BitVM-based bridge from the outset and provides flexibility to   integrate future bitcoin-specific innovations more easily.</li> </ul> <p>By building our orchestration layer from scratch, we not only gain complete control over how we manage consensus, bridge operations, and interactions with bitcoin, but we also position Strata for future extensibility without being locked into the limitations of existing SDKs or external dependencies. We do learn from the existing SDKs and borrow ideas where we can, but our custom solution allows us flexibility and specificity for our use case.</p>"},{"location":"technical/transaction-lifecycle/","title":"Transaction lifecycle","text":"<p>This document describes the journey of Strata transactions from initiation to finalization.</p>"},{"location":"technical/transaction-lifecycle/#transaction-initiation-and-propagation","title":"Transaction initiation and propagation","text":"<p>For devnet, Strata supports both Externally Owned Account (EOA) transactions and account abstraction transactions (referred to as UserOperations) as defined in ERC-4337. EOA transactions can be initiated by users through any EVM-compatible wallet that is connected to a Strata full node. For account abstraction, we provide a bundler that accepts UserOperations and relays them to a full node we have deployed. On devnet, each full node is directly connected to a full node run by Alpen Labs, which in turn is connected to the sequencer (also run by Alpen Labs). This setup helps reduce propagation time, given the relatively small number of full nodes expected. Ultimately, all user transactions reach the sequencer through this full node.</p>"},{"location":"technical/transaction-lifecycle/#block-building","title":"Block\u00a0building","text":"<p>The sequencer orders the EVM transactions received based on the default algorithm used by Reth, which is to prioritize the transactions with higher effective gas price, respecting the account nonce ordering (ascending). A block is constructed every 5 seconds, and it includes:</p> <ul> <li>A\u00a0header with\u00a0metadata\u00a0(timestamp, block\u00a0number, etc.)</li> <li>An\u00a0L1 segment\u00a0(information\u00a0from\u00a0the bitcoin\u00a0chain)</li> <li>An\u00a0execution\u00a0segment (includes the\u00a0actual EVM\u00a0transactions and related info)</li> </ul> <p>The block is executed against the current Strata chain state, during which the pending withdrawals and deposits are processed and the chain state is updated. The chain state primarily includes:</p> <ul> <li>EVM state</li> <li>Strata\u2019s view of the bitcoin state   (eg. current \"safe\" bitcoin block, blocks that may reorg, etc.)</li> <li>List of current bridge operators</li> <li>Pending deposit and withdrawal info</li> <li>Auxiliary info about the Strata chain e.g. latest Strata block,   current slot and checkpoint period, etc. More about checkpointing below.</li> </ul> <p>After the block is executed and verified, the block is added to the blockchain and is relayed to the prover and full nodes, who are all polling for new blocks.</p>"},{"location":"technical/transaction-lifecycle/#batch-building","title":"Batch building","text":"<p>A batch represents a collection of blocks associated with a single checkpoint, which includes a proof of state transition and state commitments, written to bitcoin in a bitcoin transaction. The process of building a new batch checkpoint begins when the checkpoint for the previous batch is detected on bitcoin. The first block of the new batch follows immediately after the final block of the previous batch - this applies to both the Strata and bitcoin batches. The final block in the Strata batch is chosen to be the latest block in the Strata chain, while the final block in the bitcoin batch is the most recent \"safe\" block on the bitcoin chain as seen by the sequencer. A safe block is one that has been sufficiently buried in the bitcoin chain to be resistant to reorganization.</p> <p>Once the sequencer decides on the ranges for the new batch checkpoint, the prover begins constructing an aggregated proof of state transition for that batch. Once the proof is ready, it is prepared to be written to bitcoin, along with the checkpoint information.</p>"},{"location":"technical/transaction-lifecycle/#proving","title":"Proving","text":"<p>The prover starts proving the state transition for a Strata block as soon as it is constructed by the sequencer, retrieving all the inputs necessary for proof generation from the sequencer. Since block construction by the sequencer is faster than the proof generation for a block, proof generation of multiple blocks happen in parallel. When it is time to construct a proof for a new batch, the prover retrieves previous proof information, the new batch checkpoint information, and the relevant bitcoin chain, and the prover starts two parallel processes:</p> <ol> <li>constructing a recursive proof in proper order from    the individual state transition proofs of    each Strata block generated for this batch, and</li> <li>constructing a proof by reading the bitcoin chain for the given range,    verifying its validity,    and verifying that all relevant transactions in the bitcoin chain,    such as deposits and the previous batch proof, are included in the Strata chain.    Both of these proofs are then recursively combined to create the batch proof.</li> </ol> <p>The batch proof proves the following:</p> <ul> <li>The input bitcoin chain is valid and corresponds to the range of this batch.</li> <li>Every transaction in the bitcoin chain was scanned and all   the relevant transactions   (such as the previous checkpoint transaction and deposit transactions)   are properly extracted.</li> <li>The previous batch proof in the extracted checkpoint is valid.</li> <li>All deposits initiated on bitcoin are included in the Strata batch.</li> <li>The current batch starts immediately after the last block of the previous batch.</li> <li>Execution of the Strata blocks in this batch produces a valid state transition.</li> </ul> <p>The batch proof is recursive, so by verifying the latest batch proof a client can verify that the Strata state transitions from genesis to the latest block included in the batch are valid. This batch proof is passed to the sequencer for writing to bitcoin.</p>"},{"location":"technical/transaction-lifecycle/#batch-checkpoint","title":"Batch checkpoint","text":"<p>Once the batch proof is ready, the proof is included in the checkpoint which is signed by the sequencer, compressed, and serialized into bytes. The sequencer then creates bitcoin transactions with an envelope that contains the signed checkpoint data along with Strata chain information such as the blockchain name and version.</p> <p>The transactions are then broadcast to the bitcoin network and eventually confirmed in a bitcoin block.</p>"},{"location":"technical/transaction-lifecycle/#batch-finalization","title":"Batch finalization","text":"<p>Once the bitcoin block containing the batch checkpoint is sufficiently buried in the blockchain, full nodes consider the Strata batch committed to in the checkpoint, and all transactions in that batch, to be finalized.</p>"}]}